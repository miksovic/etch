## Licensed to the Apache Software Foundation (ASF) under one
## or more contributor license agreements. See the NOTICE file
## distributed with this work for additional information
## regarding copyright ownership. The ASF licenses this file
## to you under the Apache License, Version 2.0 (the
## "License"); you may not use this file except in compliance
## with the License. You may obtain a copy of the License at
##
##   http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing,
## software distributed under the License is distributed on an
## "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
## KIND, either express or implied. See the License for the
## specific language governing permissions and limitations
## under the License.
// This file automatically generated by:
//   $version
//   $now
// This file is automatically created and should not be edited!
#set($i = $intf.name())
#set($vfname = "ValueFactory$i")
#set($intfname = "$i$suffix")
#set($clname = "Remote$intfname")

package $helper.getPackageName($intf)

import "etch"

#if($hasBaseClass)
type $clname struct {
     Remote$i
     
#else
type $clname struct {
#end
     vf   etch.ValueFactory
     Dsvc etch.DeliveryService
}

#if($hasBaseClass)
func New$clname(dsvc etch.DeliveryService, vf etch.ValueFactory ) *$clname {
     ret := &$clname{}
     ret.Dsvc = dsvc
     ret.vf = vf
     return ret
}
#end

func (remote *$clname) TransportControl(ctrl interface{}, value interface{}) {
     remote.Dsvc.TransportControl(ctrl, value)
}


#foreach($n in $intf.iterator())
#if($n.isMsgDir($mc))
#if(!$n.isHidden())
#if(!$methodList.contains($n.name().name()))
#set ( $addMethodListStatus = $methodList.add($n.name().name()))
#if($n.isOneway())
#set ($methodName = "func (r *$clname) $helper.capitalize($n.name().toString()) (")
#set( $sep = "" )
#foreach( $p in $n.iterator() )
#set ($methodName = $methodName + "$sep $p.name() $helper.getTypeName( $p.type() ) ")
#set( $sep = ", " )
#end
#set ($methodName = $methodName + ") $helper.getTypeName( $n.type() )")
$methodName {
	msg := etch.NewMessage(r.vf.GetTypeByName("$n.fqname()"), r.vf, 1)
#foreach( $p in $n.iterator() )
#if ($helper.getTypeName( $p.type() ).startsWith("*"))
	if $p.name() != nil {
#end
	  	msg.Put(r.vf.(*$vfname).$p.vname( $helper ), $p.name())
#if ($helper.getTypeName( $p.type() ).startsWith("*"))
	}
#end
#end
	r.Dsvc.TransportMessage(nil, msg)
}
#else
#set ($methodName = "func (r *$clname) $helper.capitalize($n.name().toString()) (")
#set( $sep = "" )
#foreach( $p in $n.iterator() )
#set ($methodName = $methodName + "$sep $p.name() $helper.getTypeName( $p.type() )")
#set( $sep = ", " )
#end
#set ($methodName = $methodName + ") $helper.getTypeName( $n.type() )")
$methodName {
	msg := etch.NewMessage(r.vf.GetTypeByName("$n.fqname()"), r.vf, 1)
#foreach( $p in $n.iterator() )
#if ($helper.getTypeName( $p.type() ).startsWith("*"))
	if $p.name() != nil {
#end
		msg.Put(r.vf.(*$vfname).$p.vname( $helper ), $p.name())
#if ($helper.getTypeName( $p.type() ).startsWith("*"))
    	}
#end
#end

#if($n.hasReturn())
	retVal := r.Dsvc.EndCall(r.Dsvc.BeginCall(msg), r.vf.GetTypeByName("$n.getResultMessage().fqname()"))
#if ($helper.getTypeName( $n.type() ).startsWith("int"))
	return etch.To$helper.getTypeName( $n.type() )(retVal)
#else
	return retVal.($helper.getTypeName( $n.type() ))
#end
#else
	r.Dsvc.EndCall(r.Dsvc.BeginCall(msg), r.vf.GetTypeByName("$n.getResultMessage().fqname()"))
#end
}
#end
#end
#end
#end
#end


