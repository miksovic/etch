
Session interface
=================
Object sessionQuery(Object query)
void   sessionControl(Object control, Object value)
void   sessionNotify(Object event)

Transport interface
===================
Object transportQuery(Object query)
void   transportControl(Object control, Object value)
void   transportNotify(Object event)

Source interface
================
Source<H extends SourceHandler> extends Transport
H*   getHandler();
void setHandler(H*);

SourceHandler interface
=======================
SourceHandler<S extends Source> extends Session
S*   getSource();
void setSource(S*);

PacketHandler interface
=======================
extends SourceHandler<PacketSource>
void packet(Who, flexbuf);

PacketSource interface
=======================
extends Source<PacketHandler>
int  headerSize();
void packet(Who, flexbuf);

SesssionMessage interface
=========================
extends Session
// delivers data to the session from the transport
// returns true if message consumed
boolean sessionMessage(Who from, Message)

TransportMessage interface
==========================
extends Transport<SessionMessage>
// delivers data to the transport (from the session?)
void transportMessage(Who to, Message)



- - - - - - - - - - - - - -
    message
- - - - - - - - - - - - - -

MessageSource interface
=======================
void messagex(Who, Message);

MessageHandler interface   // to deliver messages from msgizer  
<S extends Source> extends SourceHandler<S>

MessagizerMessageSource interface
=================================
extends MessageSource, Source<MessageHandler<MessagizerMessageSource>>


- - - - - - - - - - - - - -
    messagizer
- - - - - - - - - - - - - -

implements SessionPacket, TransportMessage
TransportPacket* transport;
TDI, TDO.
FlexBuffer*  msgbuf;

void TransportMessage(Who to, Message);
void SessionPacket(Who from, packetbuffer);



notes on how to destroy an object which *implements* an interface,
but where the problem code does not have a pointer to the implementing
object, but rather to the interface itself?
the use case is where we implement an object fooimpl wrapping an i_foo,
but the problem code does not save a fooimpl*, but rather saves and passes 
around an i_foo*, and the i_foo contains a void* fooimpl*

=============================================================

1. problem code does ifoo->destroy()

2. destroy_ifoo() uses its fooimpl* to do fooimpl->destroy()

3. destroy_fooimpl() does destroy_ifoo()

----------------------------------------------------------------

how to handle situation where interfaces are created separately (i.e. not in implementor ctor)?

a. problem code creates i_foo.

b. fooimpl constructor is passed i_foo*  

c. code proceeds as in prior example.