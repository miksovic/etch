##
## Licensed to the Apache Software Foundation (ASF) under one
## or more contributor license agreements.  See the NOTICE file
## distributed with this work for additional information
## regarding copyright ownership.  The ASF licenses this file
## to you under the Apache License, Version 2.0 (the
## "License"); you may not use this file except in compliance
## with the License.  You may obtain a copy of the License at
##
##   http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing,
## software distributed under the License is distributed on an
## "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
## KIND, either express or implied.  See the License for the
## specific language governing permissions and limitations
## under the License.
##

// This file automatically generated by:
//   $version
//   $now
// This file is automatically created and should not be edited!

 
/*
 * $helper.getVfFileNameH($intf)
 * $helper.getIntfName($intf) implementation of value factory
 */

#ifndef $helper.getVfName($intf).toUpperCase()_H
#define $helper.getVfName($intf).toUpperCase()_H

\#include "etch_default_value_factory.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef default_value_factory $helper.getVfName($intf).toLowerCase();

extern unsigned short CLASSID_$helper.getVfName($intf).toUpperCase()_IMPL;

#foreach($n in $intf.iterator() )
#if ($n.isStruct() || $n.isEnumx() || $n.isExcept())
unsigned short CLASSID_$helper.getServiceName($intf).toUpperCase()_$n.name().name().toUpperCase()_SERIALIZER;
#end
#end


/**
 * $helper.getVfName($intf)_statics
 */
typedef struct $helper.getVfName($intf)_statics
{
    class_to_type_map*  _etch_$helper.getVfName($intf)_c2tmap;
    vf_idname_map*      _etch_$helper.getVfName($intf)_typemap;

## generate messages
#foreach($n in $intf.iterator() )
#if($n.isMessage())
#if(!$n.isHidden())
    etch_type* _mt_$helper.getServiceName($intf)_$n.name();
#if(! $n.isOneway())
    etch_type* _mt_$helper.getServiceName($intf)__result_$n.name();
#end
#end
#end
#end

## generate stucts
#foreach($n in $intf.iterator() )
#if ($n.isStruct() || $n.isEnumx() || $n.isExcept())
    etch_type* _mt_$helper.getServiceName($intf)_$n.name();
#end
#end

	
#set ($tmp = $helper.resetHistory())
#foreach($n in $intf.iterator())
#if (!$n.isHidden())
#foreach($p in $n.iterator())
#if(!$helper.historyContains($p.name().toString()))
    etch_field* _mf_$helper.getServiceName($intf)_$p.name();
#set ($tmp = $helper.addStringToHistory($p.name().toString()))
#end
#end
##
#end
#end

#foreach($n in $intf.iterator() )
#if ($n.isStruct() || $n.isEnumx() || $n.isExcept())
    struct etch_serializer* serializer_$n.name();
#end
#end   

#set ($tmp = $helper.resetHistory())
#foreach($n in $intf.iterator())
#if (!$n.isHidden())
#foreach($p in $n.iterator())
#if(!$helper.historyContains($p.name().toString()))
    wchar_t* str_$helper.getServiceName($intf)_$p.name();
#set ($tmp = $helper.addStringToHistory($p.name().toString()))
#end
#end
##
#end
#end

#foreach($n in $intf.iterator() )
#if($n.isMessage())
    wchar_t* str_$helper.getServiceName($intf)_$n.name();
#end
#end
##generate struct names
#foreach($n in $intf.iterator() )
#if ($n.isStruct() || $n.isEnumx() || $n.isExcept())
    wchar_t* str_$helper.getIntfName($intf)_$n.name();
#end
#end

} $helper.getVfName($intf)_statics;

/**
 * $helper.getVfName($intf)_impl
 * $helper.getIntfName($intf) extension of default value factory
 */
typedef struct $helper.getVfName($intf)_impl
{
    etch_object object;    
    	
} $helper.getVfName($intf)_impl;

$helper.getVfName($intf)* new_$helper.getVfName($intf)();
$helper.getVfName($intf)_statics* $helper.getVfName($intf)_get_static();

#ifdef __cplusplus
} //extern "C"
#endif

#endif 

