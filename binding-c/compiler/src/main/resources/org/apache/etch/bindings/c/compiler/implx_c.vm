##
## Licensed to the Apache Software Foundation (ASF) under one
## or more contributor license agreements.  See the NOTICE file
## distributed with this work for additional information
## regarding copyright ownership.  The ASF licenses this file
## to you under the Apache License, Version 2.0 (the
## "License"); you may not use this file except in compliance
## with the License.  You may obtain a copy of the License at
##
##   http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing,
## software distributed under the License is distributed on an
## "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
## KIND, either express or implied.  See the License for the
## specific language governing permissions and limitations
## under the License.
##

// This file automatically generated by:
//   $version
//   $now
// This file is automatically created and should not be edited!

/*
 * $helper.getImplXFileNameI($intf, $suffix) 
 * $helper.getImplName functions which would ordinarily not be subject to edit.
 */

\#include "$helper.getImplFileNameH($intf, $suffix)"
\#include "$helper.getRemoteFileNameH($intf, $helper.getRemoteDirectionName($mc))"
\#include "etch_objecttypes.h"
\#include "etch_general.h"
\#include "etch_url.h"

int destroy_$helper.getImplName($intf, $suffix)(void*);

/* - - - - - - - - - - - - - - - - - - - - - - - -   
 *$helper.getImplName($intf, $suffix) private construction / destruction 
 * - - - - - - - - - - - - - - - - - - - - - - - -    
 */

/**
 * init_$helper.getImplName($intf, $suffix)()
 * called by $helper.getImplName($intf, $suffix) constructor to instantiate server implementation object
 * @param client the remote client, not owned.
 * @param usermem_dtor destructor for any custom memory allocations.
 */
$helper.getImplName($intf, $suffix)* init_$helper.getImplName($intf, $suffix)($helper.getRemoteName($intf, $helper.getRemoteDirectionName($mc))* $helper.getRemoteDirectionName($mc), 
    etch_object_destructor usermem_dtor)
{
#if($helper.isServer($mc))
    $helper.getImplName($intf, $suffix)* p${suffix} = ($helper.getImplName($intf, $suffix)*) new_object (sizeof($helper.getImplName($intf, $suffix)), 
        ETCHTYPEB_EXESERVERIMPL, get_dynamic_classid_unique(&CLASSID_$helper.getImplName($intf, $suffix).toUpperCase()));  
#end
#if ($helper.isClient($mc))
	$helper.getImplName($intf, $suffix)* p${suffix} = ($helper.getImplName($intf, $suffix)*) new_object (sizeof($helper.getImplName($intf, $suffix)), 
        ETCHTYPEB_EXECLIENTIMPL, get_dynamic_classid_unique(&CLASSID_$helper.getImplName($intf, $suffix).toUpperCase()));  
#end
		
    p${suffix}->$helper.getRemoteDirectionName($mc)  = $helper.getRemoteDirectionName($mc);  /* not owned */
    ((etch_object*)p${suffix})->destroy = destroy_$helper.getImplName($intf, $suffix);  /* private destructor */
    p${suffix}->destroyex = usermem_dtor;  /* user memory destructor */

    /* instantiate base */
#if ($helper.isServer($mc))
    p${suffix}->$helper.getBaseName($intf, $suffix)_base = new_$helper.getBaseName($intf, $suffix)_base(p${suffix}, NULL); /* owned */
#end
#if ($helper.isClient($mc))
    p${suffix}->$helper.getBaseName($intf, $suffix)_base = new_$helper.getBaseName($intf, $suffix)_base(p${suffix}); /* owned */
#end

    p${suffix}->i$helper.getIntfName($intf) = p${suffix}->$helper.getBaseName($intf, $suffix)_base->i$helper.getIntfName($intf);

#if ($helper.isServer($mc))
    p${suffix}->iobjsession = p${suffix}->$helper.getBaseName($intf, $suffix)_base->iobjsession;
#end
#if ($helper.isClient($mc))
    p${suffix}->iobjsession = $helper.getRemoteDirectionName($mc)->server_base->iobjsession;
#end
    p${suffix}->iobjsession->thisx = p${suffix};  /* set implementor reference */
    p${suffix}->_session_control = p${suffix}->$helper.getBaseName($intf, $suffix)_base->_session_control;
    p${suffix}->_session_notify  = p${suffix}->$helper.getBaseName($intf, $suffix)_base->_session_notify;
    p${suffix}->_session_query   = p${suffix}->$helper.getBaseName($intf, $suffix)_base->_session_query;

    return p${suffix};
}

/**
 * destroy_perf_server_impl()
 * perf_server_impl private destructor.
 * calls back to user destructor to effect cleanup of any perf_server_impl 
 * memory which may have been allocated in custom code added by user.
 */
int destroy_$helper.getImplName($intf, $suffix) (void* data)
{
    $helper.getImplName($intf, $suffix)* thisx = ($helper.getImplName($intf, $suffix)*)data;
    if (NULL == thisx) return -1;  

    if (!is_etchobj_static_content(thisx))
    {    
        if(thisx->destroyex)
        {   /* call back to user memory destructor */
            thisx->destroyex(thisx);
        }
#if ($helper.isServer($mc))           
        if(thisx->$helper.getBaseName($intf, $suffix)_base)
        {
            destroy_$helper.getBaseName($intf, $suffix)_base(thisx->$helper.getBaseName($intf, $suffix)_base);
        }
#end
    }
            
    return destroy_objectex((etch_object*)thisx);
}
