##
## Licensed to the Apache Software Foundation (ASF) under one
## or more contributor license agreements.  See the NOTICE file
## distributed with this work for additional information
## regarding copyright ownership.  The ASF licenses this file
## to you under the Apache License, Version 2.0 (the
## "License"); you may not use this file except in compliance
## with the License.  You may obtain a copy of the License at
##
##   http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing,
## software distributed under the License is distributed on an
## "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
## KIND, either express or implied.  See the License for the
## specific language governing permissions and limitations
## under the License.
##

// This file automatically generated by:
//   $version
//   $now
// This file is automatically created and should not be edited!

/*
 * $helper.getRemoteName($intf, $suffix).c
 */

\#include "$helper.getRemoteFileNameH($intf, $suffix)"
#foreach( $x in $intf.iterator() )
#if( $x.isMixin() )
#set( $m = $x.getModule() )
#foreach( $z in $m.iterator() )
\#include "$helper.getRemoteFileNameH($z, $suffix)"
#end
#end
#end
\#include "$helper.getVfFileNameH($intf)"
\#include "etch_url.h"
\#include "etch_log.h"
\#include "etch_objecttypes.h"
\#include "etch_general.h"

static const char* LOG_CATEGORY = "$helper.getRemoteName($intf, $suffix)";

unsigned short CLASSID_$helper.getRemoteName($intf, $suffix).toUpperCase();

char* $helper.getServiceName($intf).toUpperCase()_ETCHREMC = "REMC";

## generate async begin typedefs
#foreach( $n in $intf.iterator() )
#if ($n.isMessage())
#if (!$n.isHidden())
#if ($n.isMsgDir($mc) || $n.isMsgDirBoth())

#set ($sb = "$helper.getPointerTypeName($n.type()) $helper.getRemoteName($intf, '')_client_$n.name() (void*")
#foreach( $p in $n.iterator() )
#set ( $sb = "$sb, $helper.getTypeName($p.type()) $p.name()")
#end
#set ($sb = "$sb);")
$sb
#if (!$n.isOneway())
#set ($sb = "i_mailbox* $helper.getRemoteName($intf, '')_begin_client_$n.name() (void*")
#foreach( $p in $n.iterator() )
#set ( $sb = "$sb, $helper.getTypeName($p.type()) $p.name()")
#end
#set ($sb = "$sb);")
$sb
#set ($sb = "$helper.getPointerTypeName($n.type()) $helper.getRemoteName($intf, '')_end_client_$n.name()(void*, i_mailbox*);")
$sb
#end

#end
#end
#end
#end


/* generated signatures */
int destroy_$helper.getRemoteName($intf, $suffix) (void*);


/* - - - - - - - -    
 * instantiation
 * - - - - - - - -   
 */

/**
 * new_$helper.getServiceName($intf)_remote_client()
 * $helper.getRemoteName($intf, $suffix) constructor.
 */
$helper.getRemoteName($intf, $suffix)* new_$helper.getServiceName($intf)_remote_client (void* thisx, etch_session* session, etch_value_factory* vf)
{
    $helper.getRemoteName($intf, "")* remote = NULL;
    $helper.getRemoteName($intf, $suffix)* rc = NULL;

    rc = ($helper.getRemoteName($intf, $suffix)*) new_object (sizeof($helper.getRemoteName($intf, $suffix)), 
       ETCHTYPEB_REMOTECLIENT, get_dynamic_classid_unique(&CLASSID_$helper.getRemoteName($intf, $suffix).toUpperCase()));

    ((etch_object*)rc)->destroy = destroy_$helper.getRemoteName($intf, $suffix);

    /* we "implement" the service interface here since it may contain client-directed 
     * items, in which case those methods and data are exposed in this object.  we do  
     * not expose the service's server-directed methods in the remote client object.
     */
    remote = new_$helper.getRemoteName($intf, "") (thisx, session->ds, vf, NULL);
    remote->remote_type = ETCH_REMOTETYPE_CLIENT;

    rc->remote_base = remote;
    rc->client_base = new_$helper.getBaseName($intf, $suffix)_base (thisx);
    rc->session_id = session->session_id;

    rc->vf = ($helper.getVfName($intf)*) rc->remote_base->vf;

#foreach( $n in $intf.iterator() )
#if ($n.isMessage())
#if (!$n.isHidden())
#if ($n.isMsgDir($mc) || $n.isMsgDirBoth())
    rc->$n.name() = $helper.getRemoteName($intf, '')_client_$n.name();
#if (!$n.isOneway())
    rc->async_begin_$n.name() = $helper.getRemoteName($intf, '')_begin_client_$n.name();
    rc->async_end_$n.name() = $helper.getRemoteName($intf, '')_end_client_$n.name();
#end	
#end
#end
#end
#end

#foreach( $x in $intf.iterator() )
#if( $x.isMixin() )
#set( $m = $x.getModule() )
#foreach( $z in $m.iterator() )
#foreach( $n in $z.messages( true ) )
#if (!$n.isHidden())
#if ($n.isMsgDir($mc) || $n.isMsgDirBoth())	
    rc->$n.name() = $helper.getRemoteName($z, '')_client_$n.name();
#if (!$n.isOneway())
    rc->async_begin_$n.name() = $helper.getRemoteName($z, '')_begin_client_$n.name();
    rc->async_end_$n.name() = $helper.getRemoteName($z, '')_end_client_$n.name();
#end	
#end
#end
#end
#end
#end
#end

    return rc;
}


/**
 * destroy_$helper.getRemoteName($intf, $suffix)()
 * $helper.getRemoteName($intf, $suffix) destructor.
 */
int destroy_$helper.getRemoteName($intf, $suffix) (void* thisx)
{
    $helper.getRemoteName($intf, $suffix)* remote = ($helper.getRemoteName($intf, $suffix)*)thisx;
    if (NULL == remote) return -1;

    if (!is_etchobj_static_content(remote))
    {
		etch_object_destroy(remote->remote_base);
		remote->remote_base = NULL;
		etch_object_destroy(remote->client_base);
		remote->client_base = NULL;
    }
    return destroy_objectex((etch_object*)remote);
}





/**
 * perf_remote_dispose_mailbox()
 * dispose of mailbox after use.
 * this is the common means of disposing of a mailbox when we're done with it.
 * this would intuitively be part of base class code but we don't have one.
 * @param thisx the remote server this.
 * @param pibox pointer to pointer to the mailbox interface, passed indirectly
 * such that this method can null out the caller's mailbox reference.
 * @return 0 if mailbox was successfullly closed, otherwise -1. 
 * caller's i_mailbox reference is nulled out regardless of result.
 */
int $helper.getRemoteName($intf, "")_${suffix}_dispose_mailbox ($helper.getRemoteName($intf, $suffix)* thisx, i_mailbox** pibox)
{
    int result = 0;
    i_mailbox* ibox = 0;
    if (!pibox || !*pibox) return -1;
    ibox = *pibox;
    *pibox = NULL;  /* null out caller's reference */
    
    if (0 != (result = ibox->close_read (ibox)))
    {  
        /* we should not need this failsafe unregister if close_read() 
         * is reliable, since close_read() will do the unregister */
        i_mailbox_manager* imgr = ibox->manager(ibox);
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_ERROR, "could not close mailbox %x\n", ibox);
        if (imgr) result = imgr->unregister(imgr, ibox);
    }
 
    /* mailbox manager does not destroy the unregistered mailbox since it is    
     * owned by whoever registered it, that being us, so we destroy it here. 
     * debug heap issue note: this is/was the spot.
     */
    etch_object_destroy(ibox);   
    return result;
}

/**
 * perf_remote_get_stubbase()
 * convenience to return stub base object from remote server object.
 */
etch_stub* $helper.getRemoteName($intf, "")_${suffix}_get_stubbase ($helper.getRemoteName($intf, $suffix)* thisx)
{
    etch_stub* stub = NULL;
    xxxx_either_stub* clistub = (xxxx_either_stub*) thisx->client_factory->stub;
    stub = clistub? clistub->stub_base: NULL;
    return stub;
}


/**
 * $helper.getRemoteName($intf, "")_set_session_notify()
 * convenience to override remote server's session_notify().
 * @return the session_notify function that was overridden.
 */
etch_session_notify $helper.getRemoteName($intf, "")_${suffix}_set_session_notify($helper.getRemoteName($intf, $suffix)* thisx, etch_session_notify newfunc)
{
    etch_session_notify oldfunc = NULL;
    etch_stub* stub = $helper.getRemoteName($intf, "")_${suffix}_get_stubbase(thisx);
    if (NULL == stub || NULL == stub->impl_callbacks) return NULL;
    oldfunc = stub->impl_callbacks->_session_notify;
    stub->impl_callbacks->_session_notify = newfunc;
    return oldfunc;
}


/**
 * $helper.getRemoteName($intf, "")_set_session_control()
 * convenience to override remote server's session_control().
 * @return the session_control function that was overridden.
 */
etch_session_control $helper.getRemoteName($intf, "")_${suffix}_set_session_control($helper.getRemoteName($intf, $suffix)* thisx, etch_session_control newfunc)
{
    etch_session_control oldfunc = NULL;
    etch_stub* stub = $helper.getRemoteName($intf, "")_${suffix}_get_stubbase(thisx);
    if (NULL == stub || NULL == stub->impl_callbacks) return NULL;
    oldfunc = stub->impl_callbacks->_session_control;
    stub->impl_callbacks->_session_control = newfunc;
    return oldfunc;
}


/**
 * $helper.getRemoteName($intf, "")_set_session_query()
 * convenience to override remote server's session_query().
 * @return the session_query function that was overridden.
 */
etch_session_query $helper.getRemoteName($intf, "")_${suffix}_set_session_query($helper.getRemoteName($intf, $suffix)* thisx, etch_session_query newfunc)
{
    etch_session_query oldfunc = NULL;
    etch_stub* stub = $helper.getRemoteName($intf, "")_${suffix}_get_stubbase(thisx);
    if (NULL == stub || NULL == stub->impl_callbacks) return NULL;
    oldfunc = stub->impl_callbacks->_session_query;
    stub->impl_callbacks->_session_query = newfunc;
    return oldfunc;
}


/* - - - - - - - - - - - - - - - - - - - -  
 * remote procedure call implementations
 * - - - - - - - - - - - - - - - - - - - - 
 */
 
#foreach( $n in $intf.iterator() )
#if ($n.isMessage())
#if (!$n.isHidden())
#if ($n.isMsgDir($mc) || $n.isMsgDirBoth())

/* - - - - - - - - - - -  
 * $helper.getIntfName($intf).$n.name()()
 * - - - - - - - - - - -  
 */
 
#if (!$n.isOneway())
/**
 * $helper.getRemoteName($intf, '')_begin_$n.name()()
 * $helper.getIntfName($intf).$n.name() async start 
 * TODO: doc generation
 */
#set ($sb = "i_mailbox* $helper.getRemoteName($intf, '')_begin_client_$n.name()(void* thisx")
#foreach( $p in $n.iterator() )
#set ( $sb = "$sb, $helper.getTypeName($p.type()) $p.name()")
#end
#set ($sb = "$sb)")
$sb
{
    $helper.getRemoteName($intf, $suffix)* remote = ($helper.getRemoteName($intf, $suffix)*)thisx;
    int _result = 0;
    i_mailbox* _mbox = NULL;
    etch_message* _msg = NULL;
    etch_type* _msgtype = $helper.getVfName($intf)_get_static()->_mt_$helper.getServiceName($intf)_$n.name();

    do
    {   
        _msg = remote->remote_base->new_message (remote->remote_base, _msgtype);
        if (!_msg) break;

#foreach( $p in $n.iterator() )
        _result = etch_message_putc (_msg, $helper.getVfName($intf)_get_static()->_mf_$helper.getIntfName($intf)_$p.name(), (void**)&$p.name());
		if ($p.name() != NULL && 0 != _result) break; 
#end

        /* fyi msg memory is relinquished here regardless of result */ 
        _result = remote->remote_base->begin_call(remote->remote_base, _msg, (void**)&_mbox);
        _msg = NULL;

    } while(0);

    /* destroy any unrelinquished objects */
#foreach( $p in $n.iterator() )
    etch_object_destroy($p.name());
	$p.name() = NULL;
#end
    etch_object_destroy(_msg);
	_msg = NULL;
    return _mbox;
}

/**
 * $helper.getRemoteName($intf, "")_end__$n.name()()
 * _$n.name() async end (read result from mailbox and return result)
 * @param thisx this.
 * @param mbox caller relinquishes
 * @return etch_int32* result of add, caller owns.
 */
$helper.getPointerTypeName($n.type()) $helper.getRemoteName($intf, "")_end_client_$n.name() (void* thisx, i_mailbox* ibox)
{
    $helper.getRemoteName($intf, $suffix)* remote = ($helper.getRemoteName($intf, $suffix)*)thisx;
    $helper.getPointerTypeName($n.type()) _resobj = NULL;
    int _result = -1;
    etch_type* _restype = $helper.getVfName($intf)_get_static()->_mt_$helper.getServiceName($intf)__result_$n.name();

    if(ibox == NULL) {
        return NULL;
    }

    remote->remote_base->end_call(remote->remote_base, ibox, _restype, (void**)&_resobj);

    _result = $helper.getRemoteName($intf, '')_${suffix}_dispose_mailbox (thisx, &ibox);
    if(_result) {
    	etch_exception* excp = new_etch_exception_from_errorcode(ETCH_ERROR);
        etch_exception_set_message(excp,new_stringw(L"can not dispose mailbox."));
        return ($helper.getPointerTypeName($n.type()))excp;
    }

    return _resobj;
}

/**
 * $helper.getRemoteName($intf, "")_$n.name()
 * $helper.getIntfName($intf).$n.name() remote method call.
 * instantiates a mailbox, sends perf.add message, waits for result to arrive
 * in mailbox, disposes mailbox, and returns object containing add() result.
 * @param thisx this.
 * @param x etch_int32* caller relinquishes.
 * @param y etch_int32* caller relinquishes.
 * @return etch_int32* result of add, caller owns.
 */
#set ($sb = "$helper.getPointerTypeName($n.type()) $helper.getRemoteName($intf, '')_client_$n.name()(void* thisx")
#foreach( $p in $n.iterator() )
#set ( $sb = "$sb, $helper.getTypeName($p.type()) $p.name()")
#end
#set ($sb = "$sb)")
$sb
{
    $helper.getRemoteName($intf, $suffix)* remote = ($helper.getRemoteName($intf, $suffix)*)thisx;
    $helper.getPointerTypeName($n.type()) _resultobj = NULL;

#set ($sb = "i_mailbox* _mbox = $helper.getRemoteName($intf, '')_begin_client_$n.name()(remote")
#foreach( $p in $n.iterator() )
#set ( $sb = "$sb, $p.name()")
#end
#set ($sb = "$sb);")
    $sb
    
    if(_mbox == NULL){
		etch_exception* excp = new_etch_exception_from_errorcode(ETCH_EIO);
        etch_exception_set_message(excp,new_stringw(L"can not create mailbox, connection could be down."));
        return ($helper.getPointerTypeName($n.type()))excp;
	}
    
    _resultobj = $helper.getRemoteName($intf, '')_end_client_$n.name()(remote, _mbox);
    
    return _resultobj;
}

## generate oneway
#else
/**
 * $helper.getRemoteName($intf, '')_begin_$n.name()()
 * $helper.getIntfName($intf).$n.name() async start 
 * @param thisx this.
 * @param x etch_int32* caller relinquishes.
 * @param y etch_int32* caller relinquishes.
 * @param whoto recipient, caller owns it.
 * @return mailbox to receive async result. caller owns it. it may be null.
 * @remarks note that we use the putc version of message.put(), wherein we pass
 * a *reference* to the value object's pointer, and message.putc() nulls out  
 * the reference. this permits us to break when a putc() error occurs, without  
 * leaking the un-put parameters, since prior to exit we can destroy each 
 * parameter which remains non-null.
 * @remarks note also that we don't bother to clone the value keys, since they  
 * are protected objects, and while etch_message_put will appear to destroy them,
 * this will have no effect.
 */
#set ($sb = "$helper.getPointerTypeName($n.type()) $helper.getRemoteName($intf, '')_begin_client_$n.name()(void* thisx")
#foreach( $p in $n.iterator() )
#set ( $sb = "$sb, $helper.getTypeName($p.type()) $p.name()")
#end
#set ($sb = "$sb, etch_who* whoto)")
$sb
{
    $helper.getRemoteName($intf, $suffix)* remote = ($helper.getRemoteName($intf, $suffix)*)thisx;
    int _result = 0;
    etch_message* _msg = NULL;
    $helper.getPointerTypeName($n.type()) _resultobj = NULL;
    etch_type* _msgtype = $helper.getVfName($intf)_get_static()->_mt_$helper.getServiceName($intf)_$n.name();

    do
    {   
        _msg = remote->remote_base->new_message (remote->remote_base, _msgtype);
        if (!_msg) break;

#foreach( $p in $n.iterator() )
        _result = etch_message_putc (_msg, $helper.getVfName($intf)_get_static()->_mf_$helper.getIntfName($intf)_$p.name(), (void**)&$p.name());
		if ($p.name() != NULL && 0 != _result) break; 
#end

        /* fyi msg memory is relinquished here regardless of result */ 
        _resultobj = remote->remote_base->sendex (remote->remote_base, _msg, whoto);
        _msg = NULL;

    } while(0);

    /* destroy any unrelinquished objects */
#foreach( $p in $n.iterator() )
    etch_object_destroy($p.name());
	$p.name() = NULL;
#end
    etch_object_destroy(_msg);
	_msg = NULL;	
    return _resultobj;
}

/**
 * $helper.getRemoteName($intf, '')_end_$n.name()()
 * async result handler not used since $helper.getIntfName($intf).$n.name() is a one-way send-and-forget method.
 */
void* $helper.getRemoteName($intf, '')_end_client_$n.name() (void* thisx, i_mailbox* mbox)
{
    return NULL;
}

/**
 * $helper.getRemoteName($intf, '')_$n.name()()
 * $helper.getIntfName($intf).$n.name() remote 1-way method call.
 * sends $helper.getIntfName($intf).$n.name() message and does not wait for a result. if server implementation
 * code throws an exception, the exception arrives via session_notify override if any.
 * @param code an integer object, caller relinquishes.
 * @param x etch_string caller relinquishes.
 * @return integer transport result code cast to void*.
 */
#set ($sb = "$helper.getPointerTypeName($n.type()) $helper.getRemoteName($intf, '')_client_$n.name()(void* thisx")
#foreach( $p in $n.iterator() )
#set ( $sb = "$sb, $helper.getTypeName($p.type()) $p.name()")
#end
#set ($sb = "$sb)")
$sb
{
    $helper.getRemoteName($intf, $suffix)* remote = ($helper.getRemoteName($intf, $suffix)*)thisx;
    /* $helper.getIntfName($intf).$n.name() is a one-way, send-and-forget message so we only do a begin call */
#set ($sb = "$helper.getPointerTypeName($n.type()) _resultobj = $helper.getRemoteName($intf, '')_begin_client_$n.name()(remote")
#foreach( $p in $n.iterator() )
#set ( $sb = "$sb, $p.name()")
#end
#set ($sb = "$sb, NULL);")
    $sb

    return _resultobj;
}

#end
#end
#end
#end
#end
