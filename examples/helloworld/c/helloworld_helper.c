/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */


// This file automatically generated by:
//   Apache Etch 1.1.0-incubating (LOCAL-0) / c 1.1.0-incubating (LOCAL-0)
//   Fri Aug 28 15:58:20 CEST 2009
// This file is automatically created and should not be edited!


/*
 * helloworld_helper.c 
 * transport helper for helloworld service
 */
#include "helloworld_interface.h"

#include "helloworld_server.h"
#include "helloworld_server_stub.h"
#include "helloworld_remote_client.h"
#include "helloworld_client_stub.h"
#include "helloworld_remote_server.h"

#include "helloworld_helper.h"
#include "helloworld_valufact.h"
#include "etch_svcobj_masks.h"
#include "etch_objecttypes.h"
#include "etch_url.h" 
#include "etch_log.h" 

static const char* LOG_CATEGORY     = "helloworld_helper";

static int helloworld_helper_resources_init(void* data)
{
    etch_server_factory* factory = (etch_server_factory*)data;
    int result = 0;
    ETCH_ASSERT((factory != NULL) && (factory->in_valufact == NULL));
    ETCH_ASSERT (factory->in_resx && is_etch_hashtable(factory->in_resx));

    // TODO use new semantic helloworld_valuefactory_create
    factory->in_valufact = (etch_value_factory*)new_helloworld_valufact();
    ETCH_ASSERT(factory->in_valufact);
    if(factory->in_valufact == NULL) {
        return -1;
    }
    result = etch_resources_add(factory->in_resx, ETCH_RESXKEY_MSGIZER_VALUFACT, (etch_object*)factory->in_valufact);

    ETCH_ASSERT(0 == result);
    return result;
}

etch_status_t helloworld_helper_remote_server_create(helloworld_remote_server** remote_server, wchar_t* uri, void* factory_thisx, main_client_create_func client_create)
{
    etch_status_t         rv                 = ETCH_SUCCESS;
    etch_client_factory*  factory            = NULL;
    helloworld_remote_server* newremote_server   = NULL;
    i_helloworld_client*      client             = NULL;
    helloworld_client_stub*   client_stub        = NULL;
    helloworld_valufact*      vf                 = NULL;

    if(remote_server == NULL || client_create == NULL) {
        return ETCH_EINVAL;
    }

    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_INFO, "creating helloworld client ...\n");
    factory = new_client_factory (NULL, NULL, client_create);
    ETCH_ASSERT(factory != NULL);
	
	factory->thisx = factory_thisx;

    vf = new_helloworld_valufact();
    ETCH_ASSERT(vf != NULL);

    factory->in_valufact = (etch_value_factory*)vf;
    factory->in_resx     = etch_transport_resources_init(factory->in_resx);
    ETCH_ASSERT(factory->in_resx != NULL);
    etch_resources_add (factory->in_resx, ETCH_RESXKEY_MSGIZER_VALUFACT, (etch_object*)vf);

    // instantiate a delivery service
    factory->dsvc = new_etch_transport(uri, (etch_factory_params*)factory, NULL);
    ETCH_ASSERT(is_etch_ideliverysvc(factory->dsvc));

    // instantiate the remote server
    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "instantiating remote server ...\n");
    newremote_server = new_helloworld_remote_server(NULL, factory->dsvc, (etch_value_factory*)vf);
    ETCH_ASSERT(is_etch_remote_server(newremote_server));

    factory->server_id = newremote_server->server_base->server_id;
    factory->server = newremote_server;
    newremote_server->client_factory = factory;

    /* here we call back to the client constructor in [main]. the purpose of the 
     * callback is to isolate the editable xxxx_client_impl constructor from the 
     * private constructor pieces. the callback instantiates a client implenentation
     * and returns an interface to it. 
     */   
    if(factory->new_client != NULL) {
        client = factory->new_client(factory, newremote_server);
        ETCH_ASSERT(is_etch_client_base(client));
        factory->iclient = client;
    }

    // get thread pools
    factory->fpool = (etch_threadpool*)etch_resources_get(factory->in_resx, ETCH_RESXKEY_POOLTYPE_FREE);
    ETCH_ASSERT(factory->fpool);
    factory->qpool = (etch_threadpool*)etch_resources_get(factory->in_resx, ETCH_RESXKEY_POOLTYPE_QUEUED);
    ETCH_ASSERT(factory->qpool);

    // construct client stub
    client_stub = new_helloworld_client_stub(factory);
    ETCH_ASSERT(is_etch_client_stub(client_stub));
    factory->stub = client_stub;

    *remote_server = newremote_server;

    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG,"remote server instantiated\n");
    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_INFO, "helloworld client created\n");

    return rv;
}

etch_status_t helloworld_helper_remote_server_start_wait(helloworld_remote_server* remote_server, const int waitms)
{
    etch_status_t   rv           = ETCH_SUCCESS;
    helloworld_remote*  remote       = NULL;
    int             result       = 0;

    if(remote_server == NULL) {
        return ETCH_EINVAL;
    }

    remote = remote_server->remote_base;
    ETCH_ASSERT(remote != NULL);

    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_INFO, "starting helloworld client ...\n");
    result = remote->start_waitup(remote, waitms);
    if(result != 0) {
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_ERROR, "could not start helloworld client\n");
        rv = ETCH_ERROR;
    } else {
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_INFO, "helloworld client started\n");
        rv = ETCH_SUCCESS;
    }

    return rv;
}

etch_status_t helloworld_helper_remote_server_stop_wait(helloworld_remote_server* remote_server, const int waitms)
{
    etch_status_t   rv         = ETCH_SUCCESS;
    helloworld_remote*  remote     = NULL;
    int             result     = 0;

    if(remote_server == NULL) {
        return ETCH_EINVAL;
    }

    remote = remote_server->remote_base;
    ETCH_ASSERT(remote != NULL);

    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_INFO, "stopping helloworld client ...\n");
    result = remote->stop_waitdown(remote, waitms);
    if(result != 0) {
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_ERROR, "could not stop helloworld client\n");
        rv = ETCH_ERROR;
    } else {
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_INFO, "helloworld client stopped\n");
        rv = ETCH_SUCCESS;
    }

    return rv;
}

etch_status_t helloworld_helper_remote_server_destroy(helloworld_remote_server* remote_server)
{
    etch_status_t rv     = ETCH_SUCCESS;

    if(remote_server == NULL) {
        return ETCH_EINVAL;
    }

    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "destroying remote server ...\n");
    etch_object_destroy(remote_server);
    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "remote server destroyed\n");

    return rv;
}

static void* helloworld_helper_listener_create_func(void* factoryData, void* sessionData)
{
    etch_server_factory* factory = (etch_server_factory*)factoryData;
    etch_session* session = (etch_session*)sessionData;
    i_helloworld_server* iserver;
    helloworld_server_stub* stub;
    helloworld_remote_client* client;
    ETCH_ASSERT(factory && factory->helper_new_listener && factory->main_new_server);
    ETCH_ASSERT(factory->in_resx && factory->in_valufact);   // TODO assert delivery service
    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "instantiating accepted client listener ...\n");

    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "creating remote client...\n");
    client = new_helloworld_remote_client(NULL, session, factory->in_valufact);
    client->session_id = session->session_id;
    session->client = client;

    /* here we CALL BACK to the constructor in [main], the purpose of the callback
     * being to isolate the editable constructor from the private constructor. 
     * the callback instantiates a client's server implementation and returns 
     * an interface to it. 
     */ 
    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "creating server implementation ...\n");
    iserver = factory->main_new_server(factory, session);
    iserver->session_id = session->session_id;
    session->server = iserver;

    /* note that the main listener will use p->mainpool as a thread manager, not these */
    factory->qpool = (etch_threadpool*)etch_resources_get(factory->in_resx, ETCH_RESXKEY_POOLTYPE_QUEUED);
    factory->fpool = (etch_threadpool*)etch_resources_get(factory->in_resx, ETCH_RESXKEY_POOLTYPE_FREE);

    /* eventually new_helloworld_server_stub() gets to stub_base constructor, which sets
     * the delivery service's session to this, the server stub. so, in the java binding,
     * the server stub is referenced as delivery service.session. we should perhaps also 
     * store the stub opaquely in both the client and listener objects.
     */
    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "creating server stub ...\n");
    stub = new_helloworld_server_stub(factory, session);
    stub->session_id = session->session_id;
    session->server_stub = stub;

    if (iserver && stub)
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "accepted client listener instantiated\n");
    else
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_ERROR, "could not instantiate accepted client listener\n");

    return stub;
}

etch_status_t helloworld_helper_listener_create(i_sessionlistener** listener, wchar_t* uri, void* factory_thisx, main_server_create_func server_create)
{
    etch_status_t       rv          = ETCH_SUCCESS;
    i_sessionlistener*  newlistener = NULL;

    if(listener == NULL || server_create == NULL) {
        return ETCH_EINVAL;
    }

    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "instantiating main listener ...\n");

    newlistener = new_etch_listener(uri, NULL, factory_thisx, helloworld_helper_listener_create_func, server_create, helloworld_helper_resources_init);
    if(newlistener == NULL) {
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_ERROR, "could not instantiate main listener\n");
        rv = ETCH_ERROR;
    } else {
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "main listener instantiated\n");
        *listener = newlistener;
        rv = ETCH_SUCCESS;
    }

    return rv;
}

etch_status_t helloworld_helper_listener_start_wait(i_sessionlistener* listener, const int waitms)
{
    etch_status_t rv     = ETCH_SUCCESS;
    int result           = 0;

    if(listener == NULL) {
        return ETCH_EINVAL;
    }

    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_INFO, "starting main listener ...\n");

    result = listener->transport_control(listener->thisx, new_etch_event(CLASSID_CONTROL_START_WAITUP, waitms), NULL);
    if(result != 0) {
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_ERROR, "could not start main listener\n");
        rv = ETCH_ERROR;
    } else {
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_INFO, "main listener started on thread %d\n", transport_thread_id(listener));
    }

    return rv;
}

etch_status_t helloworld_helper_listener_stop_wait(i_sessionlistener* listener, const int waitms)
{
    etch_status_t rv     = ETCH_SUCCESS;
    int result           = 0;

    if(listener == NULL) {
        return ETCH_EINVAL;
    }

    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_INFO, "stopping main listener ...\n");

    result = listener->transport_control(listener->thisx, new_etch_event(CLASSID_CONTROL_STOP_WAITDOWN, waitms), NULL);
    if(result != 0) {
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_ERROR, "could not stop main listener\n");
        rv = ETCH_ERROR;
    } else {
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_INFO, "main listener ended\n");

        if (transport_session_count (listener) > 0) {
            ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "begin client sessions teardown\n");
            result = transport_teardown_client_sessions(listener);
            ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "end client sessions teardown\n");
        }
    }

    return rv;
}

etch_status_t helloworld_helper_listener_destroy(i_sessionlistener* listener)
{
    etch_status_t rv     = ETCH_SUCCESS;

    etch_object_destroy(listener);

    return rv;
}

 //isSERVER
