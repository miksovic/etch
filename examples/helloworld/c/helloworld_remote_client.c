/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */


// This file automatically generated by:
//   Apache Etch 1.1.0-incubating (LOCAL-0) / c 1.1.0-incubating (LOCAL-0)
//   Fri Aug 28 15:58:20 CEST 2009
// This file is automatically created and should not be edited!

/*
 * $helper.getRemoteName($intf, $suffix).c
 */

#include "helloworld_remote_client.h"
#include "helloworld_valufact.h"
#include "etch_url.h"
#include "etch_log.h"
#include "etch_objecttypes.h"
#include "etch_general.h"

static const char* LOG_CATEGORY = "helloworld_remote_client";

unsigned short CLASSID_HELLOWORLD_REMOTE_CLIENT;
	
char* HELLOWORLD_ETCHREMC = "REMC";



/* generated signatures */
int destroy_helloworld_remote_client (void*);


/* - - - - - - - -    
 * instantiation
 * - - - - - - - -   
 */

/**
 * new_helloworld_remote_client()
 * helloworld_remote_client constructor.
 */
helloworld_remote_client* new_helloworld_remote_client (void* thisx, etch_session* session, etch_value_factory* vf)
{
    helloworld_remote* remote = NULL;
    helloworld_remote_client* rc = NULL;

    rc = (helloworld_remote_client*) new_object (sizeof(helloworld_remote_client), 
       ETCHTYPEB_REMOTECLIENT, get_dynamic_classid_unique(&CLASSID_HELLOWORLD_REMOTE_CLIENT));

    ((etch_object*)rc)->destroy = destroy_helloworld_remote_client;

    /* we "implement" the service interface here since it may contain client-directed 
     * items, in which case those methods and data are exposed in this object.  we do  
     * not expose the service's server-directed methods in the remote client object.
     */
    remote = new_helloworld_remote (thisx, session->ds, vf, NULL);
    remote->remote_type = ETCH_REMOTETYPE_CLIENT;

    rc->remote_base = remote;
    rc->client_base = new_helloworld_client_base (thisx);
    rc->session_id = session->session_id;

	rc->vf = (helloworld_valufact*) rc->remote_base->vf;
	
    /* override client-directed virtuals with implementations here */

    return rc;
}


/**
 * destroy_helloworld_remote_client()
 * helloworld_remote_client destructor.
 */
int destroy_helloworld_remote_client (void* thisx)
{
    helloworld_remote_client* remote = (helloworld_remote_client*)thisx;
    if (NULL == remote) return -1;

    if (!is_etchobj_static_content(remote))
    {
		etch_object_destroy(remote->remote_base);
		remote->remote_base = NULL;
		etch_object_destroy(remote->client_base);
		remote->client_base = NULL;
    }
    return destroy_objectex((etch_object*)remote);
}





/**
 * perf_remote_dispose_mailbox()
 * dispose of mailbox after use.
 * this is the common means of disposing of a mailbox when we're done with it.
 * this would intuitively be part of base class code but we don't have one.
 * @param thisx the remote server this.
 * @param pibox pointer to pointer to the mailbox interface, passed indirectly
 * such that this method can null out the caller's mailbox reference.
 * @return 0 if mailbox was successfullly closed, otherwise -1. 
 * caller's i_mailbox reference is nulled out regardless of result.
 */
int helloworld_remote_client_dispose_mailbox (helloworld_remote_client* thisx, i_mailbox** pibox)
{
    int result = 0;
    i_mailbox* ibox = 0;
    if (!pibox || !*pibox) return -1;
    ibox = *pibox;
    *pibox = NULL;  /* null out caller's reference */
    
    if (0 != (result = ibox->close_read (ibox)))
    {  
        /* we should not need this failsafe unregister if close_read() 
         * is reliable, since close_read() will do the unregister */
        i_mailbox_manager* imgr = ibox->manager(ibox);
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_ERROR, "could not close mailbox %x\n", ibox);
        if (imgr) result = imgr->unregister(imgr, ibox);
    }
 
    /* mailbox manager does not destroy the unregistered mailbox since it is    
     * owned by whoever registered it, that being us, so we destroy it here. 
     * debug heap issue note: this is/was the spot.
     */
    etch_object_destroy(ibox);   
    return result;
}

/**
 * perf_remote_get_stubbase()
 * convenience to return stub base object from remote server object.
 */
etch_stub* helloworld_remote_client_get_stubbase (helloworld_remote_client* thisx)
{
    etch_stub* stub = NULL;
    xxxx_either_stub* clistub = (xxxx_either_stub*) thisx->client_factory->stub;
    stub = clistub? clistub->stub_base: NULL;
    return stub;
}


/**
 * helloworld_remote_set_session_notify()
 * convenience to override remote server's session_notify().
 * @return the session_notify function that was overridden.
 */
etch_session_notify helloworld_remote_client_set_session_notify(helloworld_remote_client* thisx, etch_session_notify newfunc)
{
    etch_session_notify oldfunc = NULL;
    etch_stub* stub = helloworld_remote_client_get_stubbase(thisx);
    if (NULL == stub || NULL == stub->impl_callbacks) return NULL;
    oldfunc = stub->impl_callbacks->_session_notify;
    stub->impl_callbacks->_session_notify = newfunc;
    return oldfunc;
}


/**
 * helloworld_remote_set_session_control()
 * convenience to override remote server's session_control().
 * @return the session_control function that was overridden.
 */
etch_session_control helloworld_remote_client_set_session_control(helloworld_remote_client* thisx, etch_session_control newfunc)
{
    etch_session_control oldfunc = NULL;
    etch_stub* stub = helloworld_remote_client_get_stubbase(thisx);
    if (NULL == stub || NULL == stub->impl_callbacks) return NULL;
    oldfunc = stub->impl_callbacks->_session_control;
    stub->impl_callbacks->_session_control = newfunc;
    return oldfunc;
}


/**
 * helloworld_remote_set_session_query()
 * convenience to override remote server's session_query().
 * @return the session_query function that was overridden.
 */
etch_session_query helloworld_remote_client_set_session_query(helloworld_remote_client* thisx, etch_session_query newfunc)
{
    etch_session_query oldfunc = NULL;
    etch_stub* stub = helloworld_remote_client_get_stubbase(thisx);
    if (NULL == stub || NULL == stub->impl_callbacks) return NULL;
    oldfunc = stub->impl_callbacks->_session_query;
    stub->impl_callbacks->_session_query = newfunc;
    return oldfunc;
}


/* - - - - - - - - - - - - - - - - - - - -  
 * remote procedure call implementations
 * - - - - - - - - - - - - - - - - - - - - 
 */
 
