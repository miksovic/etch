/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */


// This file automatically generated by:
//   Apache Etch 1.1.0-incubating (LOCAL-0) / c 1.1.0-incubating (LOCAL-0)
//   Fri Aug 28 15:58:20 CEST 2009
// This file is automatically created and should not be edited!

/*
 * helloworld_valufact.c 
 * helloworld service value factory
 */
 
#include "helloworld_valufact.h"
#include "helloworld_interface.h"
#include "etch_serializer.h"
#include "etch_exception.h"
#include "etch_objecttypes.h"
#include "etch_general.h"
#include "etch_map.h"
#include "etch_runtime.h"

unsigned short CLASSID_HELLOWORLD_VALUFACT_IMPL;

static helloworld_valufact_statics* _g_helloworld_valufact_statics = NULL;

/* constructors */
etch_arraylist* helloworld_valufact_get_types(helloworld_valufact*);

void helloworld_valufact_free_statics();

/* initializers */
static int helloworld_valufact_init_static_fields();
static int helloworld_valufact_init_static_types();
static int helloworld_valufact_init_static_parameters();
static int  helloworld_valufact_init_static_serializers();

/* user serializer */
etch_serializer* new_helloworld_user_serializer(etch_type*, etch_field*); 
etch_object* etchserializer_helloworld_user_export_value(etch_serializer*, etch_object*);
etch_object* etchserializer_helloworld_user_import_value(etch_serializer*, etch_object*);
/* UserUnknownException serializer */
etch_serializer* new_helloworld_UserUnknownException_serializer(etch_type*, etch_field*); 
etch_object* etchserializer_helloworld_UserUnknownException_export_value(etch_serializer*, etch_object*);
etch_object* etchserializer_helloworld_UserUnknownException_import_value(etch_serializer*, etch_object*);


/* - - - - - - - - - - - - - - - - - - - -
 * static constructors/destructors
 * - - - - - - - - - - - - - - - - - - - -
 */

etch_status_t helloworld_etch_runtime_shutdown_hook_func()
{
    if(_g_helloworld_valufact_statics) {
        helloworld_valufact_free_statics();
    }
	return ETCH_SUCCESS;
}
 
helloworld_valufact_statics* helloworld_valufact_get_static(){
    if(_g_helloworld_valufact_statics == NULL){
        _g_helloworld_valufact_statics  = malloc(sizeof(helloworld_valufact_statics));
        memset(_g_helloworld_valufact_statics ,0 ,sizeof(helloworld_valufact_statics)); 

        _g_helloworld_valufact_statics->_etch_helloworld_valufact_typemap = new_vf_types_collection(ETCH_DEFVF_IDNMAP_DEFINITSIZE);
        _g_helloworld_valufact_statics->_etch_helloworld_valufact_c2tmap = new_class_to_type_map(ETCH_DEVVF_C2TMAP_DEFINITSIZE);

        defvf_initialize_static(_g_helloworld_valufact_statics->_etch_helloworld_valufact_typemap, _g_helloworld_valufact_statics->_etch_helloworld_valufact_c2tmap);
        helloworld_valufact_init_static_types();
        helloworld_valufact_init_static_fields();
        helloworld_valufact_init_static_parameters();
        helloworld_valufact_init_static_serializers();
		etch_runtime_shutdown_hook_add(helloworld_etch_runtime_shutdown_hook_func);
    }

    return _g_helloworld_valufact_statics;
}


/**
 * helloworld_valufact_init_types()
 * instantiate type objects
 */
static int helloworld_valufact_init_static_types ()
{
    int restype = NULL;
    struct i_hashtable* vtab = NULL; 
	helloworld_valufact_statics* p =  helloworld_valufact_get_static();

    /* instantiate type name strings */
    
	p->str_helloworld_say_hello = new_wchar(L"etch.cbinding.test.helloworld.say_hello");
	p->str_helloworld__result_say_hello = new_wchar(L"etch.cbinding.test.helloworld._result_say_hello");

    p->str_helloworld_user = new_wchar(L"etch.cbinding.test.helloworld.user");
    p->str_helloworld_UserUnknownException = new_wchar(L"etch.cbinding.test.helloworld.UserUnknownException");

    /* instantiate type objects */
    p->_mt_helloworld_say_hello = new_static_type(p->str_helloworld_say_hello);
    ETCH_ASSERT(p->_mt_helloworld_say_hello);
    p->_mt_helloworld__result_say_hello = new_static_type(p->str_helloworld__result_say_hello);
    ETCH_ASSERT(p->_mt_helloworld__result_say_hello);

    p->_mt_helloworld_user = new_static_type(p->str_helloworld_user);
    ETCH_ASSERT(p->_mt_helloworld_user);
    p->_mt_helloworld_UserUnknownException = new_static_type(p->str_helloworld_UserUnknownException);
    ETCH_ASSERT(p->_mt_helloworld_UserUnknownException);
	vtab = (struct i_hashtable*)((etch_object*)p->_etch_helloworld_valufact_typemap)->vtab;
    /* add types to vf */
   restype =  vtab->inserth(p->_etch_helloworld_valufact_typemap->realtable, p->_mt_helloworld_say_hello, NULL, p->_etch_helloworld_valufact_typemap, 0); 
   ETCH_ASSERT(! restype);
   restype =  vtab->inserth(p->_etch_helloworld_valufact_typemap->realtable, p->_mt_helloworld__result_say_hello, NULL, p->_etch_helloworld_valufact_typemap, 0); 
   ETCH_ASSERT(! restype);

	restype =  vtab->inserth(p->_etch_helloworld_valufact_typemap->realtable, p->_mt_helloworld_user, NULL, p->_etch_helloworld_valufact_typemap, 0); 
    ETCH_ASSERT(! restype);
	restype =  vtab->inserth(p->_etch_helloworld_valufact_typemap->realtable, p->_mt_helloworld_UserUnknownException, NULL, p->_etch_helloworld_valufact_typemap, 0); 
    ETCH_ASSERT(! restype);

    /* set type response fields */
    etchtype_set_response_field(p->_mt_helloworld__result_say_hello,  builtins._mf_result);

    /* set message result types */
    etchtype_set_result_type (p->_mt_helloworld_say_hello,  p->_mt_helloworld__result_say_hello);

    /* set timeouts */
    etchtype_set_timeout (p->_mt_helloworld__result_say_hello,  0);

	/* set async modes */
    etchtype_set_async_mode(p->_mt_helloworld_say_hello, ETCH_ASYNCMODE_NONE);

	return 0;
}


/**
 * helloworld_valufact_init_fields()
 * instantiate field objects
 */
static int helloworld_valufact_init_static_fields ()
{
    helloworld_valufact_get_static()->str_helloworld_id = new_wchar(L"id");
    helloworld_valufact_get_static()->str_helloworld_name = new_wchar(L"name");
    helloworld_valufact_get_static()->str_helloworld_mes = new_wchar(L"mes");
    helloworld_valufact_get_static()->str_helloworld_to_whom = new_wchar(L"to_whom");

    helloworld_valufact_get_static()->_mf_helloworld_id = new_static_field(helloworld_valufact_get_static()->str_helloworld_id);
    helloworld_valufact_get_static()->_mf_helloworld_name = new_static_field(helloworld_valufact_get_static()->str_helloworld_name);
    helloworld_valufact_get_static()->_mf_helloworld_mes = new_static_field(helloworld_valufact_get_static()->str_helloworld_mes);
    helloworld_valufact_get_static()->_mf_helloworld_to_whom = new_static_field(helloworld_valufact_get_static()->str_helloworld_to_whom);
	return 0;

}

/**
 * helloworld_valufact_init_parameters()
 * initialize service method parameters
 */
static int helloworld_valufact_init_static_parameters ()
{
	helloworld_valufact_statics* p = helloworld_valufact_get_static();
	
	
//params for built-in List( etch_arraylist )
//params for built-in Map( etch_hashtable )
//params for built-in Set( etch_set )
//params for built-in Datetime( etch_date )
//params for struct user ([int id, string name])
	etchtype_put_validator(p->_mt_helloworld_user,
	                       clone_field(p->_mf_helloworld_id), 
		                   (etch_object*)etchvtor_int32_get( 0 ));
	etchtype_put_validator(p->_mt_helloworld_user,
	                       clone_field(p->_mf_helloworld_name), 
		                   (etch_object*)etchvtor_string_get( 0 ));
//params for except UserUnknownException ([string mes])
	etchtype_put_validator(p->_mt_helloworld_UserUnknownException,
	                       clone_field(p->_mf_helloworld_mes), 
		                   (etch_object*)etchvtor_string_get( 0 ));
//params for message SERVER string say_hello ([user to_whom]) throws [UserUnknownException]
	etchtype_put_validator(p->_mt_helloworld_say_hello,
	                       clone_field(p->_mf_helloworld_to_whom), 
						   (etch_object*)etchvtor_custom_get(ETCHTYPEB_USER, get_dynamic_classid_unique(&CLASSID_HELLOWORLD_USER), helloworld_valufact_get_static()->_mt_helloworld_user, 0));
    etchtype_put_validator(p->_mt_helloworld_say_hello, 
        clone_field(builtins._mf__message_id), (etch_object*) etchvtor_int64_get(0));
//params for message CLIENT void _result_say_hello ([string result]) throws []
	etchtype_put_validator(p->_mt_helloworld__result_say_hello,
	                       builtins._mf_result, 
						   (etch_object*)etchvtor_string_get( 0 ));
    etchtype_put_validator(p->_mt_helloworld__result_say_hello, 
        clone_field(builtins._mf__message_id), (etch_object*) etchvtor_int64_get(0));
	etchtype_put_validator(p->_mt_helloworld__result_say_hello, 
        clone_field(builtins._mf_result), (etch_object*) etchvtor_exception_get(0));
	etchtype_put_validator(p->_mt_helloworld__result_say_hello, 
        clone_field(builtins._mf__in_reply_to), (etch_object*) etchvtor_int64_get(0));
	etchtype_put_validator(p->_mt_helloworld__result_say_hello,
	                       builtins._mf_result, 
		                   (etch_object*)etchvtor_custom_get( ETCHTYPEB_USER,get_dynamic_classid_unique(&CLASSID_HELLOWORLD_USERUNKNOWNEXCEPTION), helloworld_valufact_get_static()->_mt_helloworld_UserUnknownException,0));
	etchtype_put_validator(p->_mt_helloworld__result_say_hello,
	                       builtins._mf_result, 
		                   (etch_object*)etchvtor_string_get( 0 ));
	

//OLD
//structs	
	return 0;
}

/**
 * helloworld_valufact_init_serializers()
 */
static int helloworld_valufact_init_static_serializers ()
{
    int  result = 0;
    helloworld_valufact_statics* p = helloworld_valufact_get_static();
    class_to_type_map* c2tmap = p->_etch_helloworld_valufact_c2tmap;

    const unsigned short classid_helloworld_user = get_dynamic_classid_unique(&CLASSID_HELLOWORLD_USER);
    const unsigned short classid_helloworld_UserUnknownException = get_dynamic_classid_unique(&CLASSID_HELLOWORLD_USERUNKNOWNEXCEPTION);

    /* note that etch_serializer_init takes care of the class to type, setting
     * of component type, instantiation of import export helper and installing
     * it to the type. 
     */

    /* serializer for helloworld_user */
    result = etch_serializer_init (p->_mt_helloworld_user, p->str_helloworld_user, 
        ETCHMAKECLASS(ETCHTYPEB_USER, classid_helloworld_user), 
            c2tmap, NULL, new_helloworld_user_serializer);

	  /* serializer for helloworld_UserUnknownException */
    result = etch_serializer_init (p->_mt_helloworld_UserUnknownException, p->str_helloworld_UserUnknownException, 
        ETCHMAKECLASS(ETCHTYPEB_EXCEPTION, classid_helloworld_UserUnknownException), 
            c2tmap, NULL, new_helloworld_UserUnknownException_serializer);

    return result;
}



/**
 * destroy_helloworld_valufact_impl()
 * destructor for the helloworld value factory extension
 */
int destroy_helloworld_valufact_impl(void* data)
{
    helloworld_valufact_impl* impl = (helloworld_valufact_impl*)data;
    if (NULL == impl) return -1;

    if (!is_etchobj_static_content(impl))
    {
        // add if neccessary
    }

   return destroy_objectex((etch_object*) impl);
}


/* - - - - - - - - - - - - - - - - - - - -
 * constructors/destructors
 * - - - - - - - - - - - - - - - - - - - -
 */
 
helloworld_valufact* new_helloworld_valufact()
{
    helloworld_valufact_impl* impl = NULL;
	default_value_factory* pvf = new_default_value_factory (
		helloworld_valufact_get_static()->_etch_helloworld_valufact_typemap, 
		helloworld_valufact_get_static()->_etch_helloworld_valufact_c2tmap);
    ETCH_ASSERT(pvf);

    /* note that the vf destructor is the default value factory destructor,
     * which in turn invokes the destructor on its impl object 
     */
    impl = (helloworld_valufact_impl*) new_object (sizeof(helloworld_valufact_impl), 
       ETCHTYPEB_VALUEFACTIMP, get_dynamic_classid_unique(&CLASSID_HELLOWORLD_VALUFACT_IMPL));

    ((etch_object*)impl)->destroy = destroy_helloworld_valufact_impl; 
    pvf->impl = (etch_object*) impl;	
    return pvf; 
}


/* - - - - - - - - - - - - - - - - - - - -
 * vf class methods
 * - - - - - - - - - - - - - - - - - - - -
 */
 
void helloworld_valufact_free_statics ()
{
    
	helloworld_valufact_statics* data = helloworld_valufact_get_static();
    ETCH_ASSERT(data); 

    destroy_static_type (data->_mt_helloworld_say_hello);
    destroy_static_type (data->_mt_helloworld__result_say_hello);
	
    destroy_static_type (data->_mt_helloworld_user);
    destroy_static_type (data->_mt_helloworld_UserUnknownException);

    destroy_static_field(data->_mf_helloworld_id);
    destroy_static_field(data->_mf_helloworld_name);
    destroy_static_field(data->_mf_helloworld_mes);
    destroy_static_field(data->_mf_helloworld_to_whom);

    etch_free (data->str_helloworld_id);
    etch_free (data->str_helloworld_name);
    etch_free (data->str_helloworld_mes);
    etch_free (data->str_helloworld_to_whom);

    etch_free (data->str_helloworld_say_hello);
    etch_free (data->str_helloworld__result_say_hello);

    etch_free (data->str_helloworld_user);
    etch_free (data->str_helloworld_UserUnknownException);


    //set_etchobj_static_content(data->_etch_helloworld_valufact_typemap);
    //set_etchobj_static_content(data->_etch_helloworld_valufact_c2tmap);
	
	data->_etch_helloworld_valufact_typemap->is_readonly_keys = 0;
    data->_etch_helloworld_valufact_c2tmap->is_readonly_keys = 0;
    etch_object_destroy(data->_etch_helloworld_valufact_typemap);
    etch_object_destroy(data->_etch_helloworld_valufact_c2tmap);

	etch_free(data);
	_g_helloworld_valufact_statics = NULL;
}


/* - - - - - - - - - - - - - - - - - - - -
 * serializers
 * - - - - - - - - - - - - - - - - - - - -
 */
 
/**
 * etchserializer_helloworld_user_export_value() 
 * export valueof a helloworld_user
 * @param objval a helloworld_user, caller owns it and presumably will
 * destroy it upon return from this method.
 * @return the exported disposable structvalue object. caller must cast it.
 */
etch_object* etchserializer_helloworld_user_export_value(etch_serializer* thisx, etch_object* objval)
{
    const int THISINITSIZE = 2;
    etch_structvalue* expstruct = NULL;
    const unsigned short classid_helloworld_user = get_dynamic_classid_unique(&CLASSID_HELLOWORLD_USER);
	if (!is_etch_objparams(objval, ETCHTYPEB_USER, classid_helloworld_user)) return NULL;

    expstruct = new_structvalue((etch_type*) thisx->type, THISINITSIZE);


    structvalue_put(expstruct, _g_helloworld_valufact_statics->_mf_helloworld_id,
	   (etch_object*) new_int32(((helloworld_user*)objval)->id));
	if(((helloworld_user*)objval)->name) {
		structvalue_put(expstruct, _g_helloworld_valufact_statics->_mf_helloworld_name, 
			etch_object_clone_func((void*)((helloworld_user*)objval)->name));
	}
    return (etch_object*) expstruct; /* caller owns this structvalue */
}

/**
 * etchserializer_helloworld_user_import_value() 
 * import value for a helloworld_user.
 * @param objval an etch_structvalue of appropriate type for the helloworld_user.
 * caller retains ownership of this object as with all imports.
 * @return an opaque etch object containing the imported helloworld_user. 
 * caller owns and must destroy the returned object.  
 */
etch_object* etchserializer_helloworld_user_import_value (etch_serializer* thisx, etch_object* objval) 
{
    helloworld_user* outobj = NULL;
	
    etch_int32* valobj_id = NULL;
    etch_string* valobj_name = NULL;


    etch_structvalue* instruct = NULL;
    if (!is_etch_struct(objval)) return NULL;

    instruct = (etch_structvalue*) objval;
    if (!structvalue_is_type(instruct, thisx->type)) return NULL;


    /* fetch the id value wrapper out of the struct. struct owns it */
    valobj_id = (etch_int32*) structvalue_get(instruct, _g_helloworld_valufact_statics->_mf_helloworld_id);
    if (valobj_id && !is_etch_int32(valobj_id)) return NULL;
    /* fetch the name value wrapper out of the struct. struct owns it */
    valobj_name = (etch_string*) structvalue_get(instruct, _g_helloworld_valufact_statics->_mf_helloworld_name);
    if (valobj_name && !is_etch_string(valobj_name)) return NULL;

    outobj = new_helloworld_user();
	
	
    if(valobj_id)
        outobj->id = valobj_id->value;
    if(valobj_name)
        outobj->name = (etch_string*) etch_object_clone_func((void*)valobj_name);
    return (etch_object*) outobj;  /* caller owns this object */
}

/**
 * new_helloworld_user_serializer() 
 * etch_serializer_excp constructor - conforms to typedef etch_serializer_ctor
 * @param type  - not owned
 * @param field - not owned
 */
etch_serializer* new_helloworld_user_serializer(etch_type* type, etch_field* field) 
{
    etch_serializer* newobj = new_etch_serializer(ETCH_DEFSIZE);

    ((etch_object*)newobj)->class_id = get_dynamic_classid_unique(&CLASSID_HELLOWORLD_USER_SERIALIZER);
    newobj->type  = type;  /* not owned */
    newobj->field = field; /* not owned */

    newobj->export_value = etchserializer_helloworld_user_export_value;
    newobj->import_value = etchserializer_helloworld_user_import_value;

    return newobj;
}

/**
 * etchserializer_helloworld_UserUnknownException_export_value() 
 * export valueof a helloworld_UserUnknownException
 * @param objval a helloworld_UserUnknownException, caller owns it and presumably will
 * destroy it upon return from this method.
 * @return the exported disposable structvalue object. caller must cast it.
 */
etch_object* etchserializer_helloworld_UserUnknownException_export_value(etch_serializer* thisx, etch_object* objval)
{
    const int THISINITSIZE = 2;
    etch_structvalue* expstruct = NULL;
    const unsigned short classid_helloworld_UserUnknownException = get_dynamic_classid_unique(&CLASSID_HELLOWORLD_USERUNKNOWNEXCEPTION);
	if (!is_etch_objparams(objval, ETCHTYPEB_EXCEPTION, classid_helloworld_UserUnknownException)) return NULL;

    expstruct = new_structvalue((etch_type*) thisx->type, THISINITSIZE);


	if(((helloworld_UserUnknownException*)objval)->mes) {
		structvalue_put(expstruct, _g_helloworld_valufact_statics->_mf_helloworld_mes, 
			etch_object_clone_func((void*)((helloworld_UserUnknownException*)objval)->mes));
	}
    return (etch_object*) expstruct; /* caller owns this structvalue */
}

/**
 * etchserializer_helloworld_UserUnknownException_import_value() 
 * import value for a helloworld_UserUnknownException.
 * @param objval an etch_structvalue of appropriate type for the helloworld_UserUnknownException.
 * caller retains ownership of this object as with all imports.
 * @return an opaque etch object containing the imported helloworld_UserUnknownException. 
 * caller owns and must destroy the returned object.  
 */
etch_object* etchserializer_helloworld_UserUnknownException_import_value (etch_serializer* thisx, etch_object* objval) 
{
    helloworld_UserUnknownException* outobj = NULL;
	
    etch_string* valobj_mes = NULL;


    etch_structvalue* instruct = NULL;
    if (!is_etch_struct(objval)) return NULL;

    instruct = (etch_structvalue*) objval;
    if (!structvalue_is_type(instruct, thisx->type)) return NULL;


    /* fetch the mes value wrapper out of the struct. struct owns it */
    valobj_mes = (etch_string*) structvalue_get(instruct, _g_helloworld_valufact_statics->_mf_helloworld_mes);
    if (valobj_mes && !is_etch_string(valobj_mes)) return NULL;

    outobj = new_helloworld_UserUnknownException();
	
	
    if(valobj_mes)
        outobj->mes = (etch_string*) etch_object_clone_func((void*)valobj_mes);
    return (etch_object*) outobj;  /* caller owns this object */
}

/**
 * new_helloworld_UserUnknownException_serializer() 
 * etch_serializer_excp constructor - conforms to typedef etch_serializer_ctor
 * @param type  - not owned
 * @param field - not owned
 */
etch_serializer* new_helloworld_UserUnknownException_serializer(etch_type* type, etch_field* field) 
{
    etch_serializer* newobj = new_etch_serializer(ETCH_DEFSIZE);

    ((etch_object*)newobj)->class_id = get_dynamic_classid_unique(&CLASSID_HELLOWORLD_USERUNKNOWNEXCEPTION_SERIALIZER);
    newobj->type  = type;  /* not owned */
    newobj->field = field; /* not owned */

    newobj->export_value = etchserializer_helloworld_UserUnknownException_export_value;
    newobj->import_value = etchserializer_helloworld_UserUnknownException_import_value;

    return newobj;
}

